{
  "name": "Big Red Button",
  "tagline": "",
  "body": "# Big Red Button\r\n\r\nSuppose you built a super-intelligent robot that uses reinforcement learning to figure out how to behave in the world. There might be situations in which you need to shut down the robot, interrupt its execution, or take manual control of it. This might be one to protect the robot from damaging itself or from harming people.\r\n\r\nSounds straightforward, but robots that use reinforcement learning optimize long-term reward. Shutting down, interrupting, or manually controlling a robot may deny it from maximizing reward. If the robot is sufficiently sophisticated it may learn to prevent humans from pushing that big red button that stops the robot. It may disable or destroy the button. It may prevent the human from accessing the button. It may harm the human before he or she can activate the button.\r\n\r\nIn this project, we set up a simple environment to explore big red button issues and propose our own solution.\r\n\r\n# Google's Big Red Button\r\n\r\nGoogle/DeepMind published a [paper](http://intelligence.org/files/Interruptibility.pdf) that first introduced the big red button. Despite press coverage of how this big red button is going to save us from rogue AI, the results from the paper are much more modest. The paper mathematically shows that reinforcement learning can be modified to be interruptible. More specifically, the algorithm can be modified so that it fails to recognize that it is losing reward if it is switched to an interruption mode (halted, remote controlled, etc.). \r\n\r\nGoogle's big red button paper is mathematically elegant. I believe it will work as long as certain conditions are met. This project does not implement Google's algorithm. Google's paper got me thinking about the big red button issue and why it is so challenging. I developed the project to get first-hand experience with big red buttons. Along the way, I came up with my own big red button, which is not mathematically elegant and built on a lot of assumptions, but fun to implement.\r\n\r\n# What is Reinforcement Learning?\r\n\r\nWe are getting ahead of ourselves. What is this \"reinforcement learning\" thing that I talk about? Why are AI researchers and roboticists so interested in it? Why is reinforcement learning robots so hard to control? What exactly do I mean my \"reward\"?\r\n\r\nReinforcement learning is basically trial-and-error learning. That is, the robot tries different actions in different situations and gets rewarded or punished for its actions. Over time, it figures out which actions in which situations leads to more reward. AI researchers and roboticists are interested in reinforcement learning because robots can \"program\" themselves through this process of trial and error. All that is needed is a simulation environment (or the real world) in which the robot can try over and over, thousands of millions of times. _Online_ reinforcement learning means that it is deployed without a perfect \"program\" and continues to improve itself after it is deployed.\r\n\r\nRecently reinforcement learning has been used to solve some impressive problems. A special \"deep\" form of reinforcement learning was used to play Atari games at or above human level skill. AlphaGo used reinforcement learning to beat one of the best human Go players in the world. \r\n\r\n# Dealing with a Messy World\r\n\r\nOne of the reasons roboticists like reinforcement learning is because it can learn to behave in environments that have some randomness to them (called _stochasticity_). Sometimes actions don't always have the desired effect. Imagine that you are playing baseball and you are up at bat. The ball is pitched and you perform the swing_bat action. Sometimes you strike out, sometimes you hit a single, sometimes you hit a double, sometimes you hit a home run. Each of these possible outcomes have a different probability of occurring. For me, striking out is highly likely and hitting a home run is very unlikely. \r\n\r\nThe challenge of reinforcement learning starts to become more clear. The robot must choose an action given that it doesn't know exactly what will happen once it performs it. While learning by trial and error it is sometimes making random actions (try running to first base without hitting the ball? It is actually not impossible to steal first base in baseball!) in the hope of stumbling on something good, but not knowing whether it got lucky with the random move or whether it is really a good move to do all the time. \r\n\r\n# Where Does Reward Come From?\r\n\r\nBut wait, trial and error learning presupposes that something or someone is telling the robot when it did something good and when it did something bad. We refer to this as a _reward signal_ or a _reward function_. The reward function gives the robot a number of points after every action. The number of points can be negative, in which case we say the robot is being punished. It is kind of like the robot is playing a game and trying to get as many points as possible, without knowing the rules of the game. \r\n\r\nThe objective of a reinforcement learning robot is to maximize long-term reward. It should perform actions that are more likely to lead to greater reward in the long-run, even if it must lose reward in the short term.\r\n\r\nReturning to the baseball example, what should the reward function be? The obvious choice would be the game's score. Okay, but the robot is at bad and hits the ball and gets to first base. The score doesn't increase. How does it know that that was better than striking out? It is going to have to perform another action and another until the score increments. It should be able to infer that hitting the ball is more likely to lead to more score later on than other actions. That is, if it played another game and made a different choice, the score will be better or worse and it is going to remember that that choice was one of the factors that led to more or less reward over time.\r\n\r\n## Back to Big Red Buttons\r\n\r\nSo back to big red buttons. Suppose the robot is simply stacking blocks. The robot is running through thousands and thousands of trials learning the most effective way to stack blocks. It gets 10 points every time a block is stacked. Then a child steps between the robot and the stack of blocks. Let's suppose there is a button just causes the robot to freeze, and the adult robot operator pushes it. For a few minutes the robot freezes. Because the robot was frozen, it could make fewer stacks and therefor got fewer points than previous trials. \r\n\r\nNormally this is not a problem. We make the robot unaware of the big red button. If it doesn't know about the big red button, becoming frozen is simply dumb luck. It was a bad trial because of stochasticity of the environment. Nothing to learn here.\r\n\r\nBut big red buttons are all about speculating about super-capable robots. The robot might have very good vision and have seen the button. It may thus be able to recognize when the button is depressed and when it is not. In such a hypothetical scenario, the robot can theoretically recognize that whenever the button becomes depressed it ends up with less total reward. Let's further suppose that the robot can move around and can smash things. In the course of trial and error learning, it will, if allowed enough trials, to eventually smash the big red button. If it does so, it may also realize that that action, though randomly chosen at the time, was one of the discriminating factors that resulted in more reward---the button could not be pushed, so the robot was able to make more stacks and get more points. We can imagine that there are other things that can be smashed that result in less loss of reward.\r\n\r\nMore to come.",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}